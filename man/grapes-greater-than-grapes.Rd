% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EL_test.R, R/EL_test_parallel.R,
%   R/add_activity_profile.R, R/add_helper_columns.R, R/bootstrap_U_star.R,
%   R/bootstrap_U_star_parallel.R, R/create_activity_profile.R, R/ee_model.R,
%   R/extract_activity_grid.R, R/generate_data.R, R/initialize_grid.R,
%   R/neg2logRa.R, R/prepare_sim_data.R, R/scale_activity_profile.R
\name{\%>\%}
\alias{\%>\%}
\alias{EL_test}
\alias{EL_test_parallel}
\alias{add_activity_profile}
\alias{add_helper_columns}
\alias{bootstrap_U_star}
\alias{bootstrap_U_star_parallel}
\alias{create_activity_profile}
\alias{ee_model}
\alias{extract_activity_grid}
\alias{generate_data}
\alias{initialize_grid}
\alias{neg2logRa}
\alias{prepare_sim_data}
\alias{scale_activity_profile}
\title{Calculates functional ANOVA test on activity profiles}
\usage{
EL_test(
  data,
  activity_col,
  group_col,
  grid_length = 100,
  n_boot = 1000,
  quantiles = c(0.05, 0.95),
  alpha = 0.95,
  verbose = FALSE
)

EL_test_parallel(
  data,
  activity_col,
  group_col,
  grid_length = 100,
  n_boot = 1000,
  quantiles = c(0.05, 0.95),
  alpha = 0.95,
  n_cores = 2
)

add_activity_profile(
  data,
  activity_col,
  group_col,
  grid_length = 100,
  quantiles = c(0.05, 0.95)
)

add_helper_columns(data, group_col)

bootstrap_U_star(data, group_col, id_col, n_boot = 1000)

bootstrap_U_star_parallel(data, n_boot = 1000, n_cores = 2)

create_activity_profile(activity, activity_grid)

ee_model(lambda_gamma, data)

extract_activity_grid(
  data,
  activity_col,
  group_col,
  grid_length = 100,
  quantiles = c(0.05, 0.95)
)

generate_data(n_subj, group_id, n_points, scaling, thetas)

initialize_grid(
  data,
  mu_grid_length = 20,
  lambda_grid_length = 20,
  mu_tolerance = 20,
  lambda_tolerance = 20
)

neg2logRa(data, a, group_col, verbose = FALSE)

prepare_sim_data(group_params, quantiles = c(0.05, 0.95))

scale_activity_profile(data, a, group_col)
}
\arguments{
\item{data}{dataset containing the activity profiles}

\item{activity_col}{the name of the column that contains the activity data}

\item{group_col}{the column that contains the group ID column}

\item{grid_length}{number describing how long the activity grid should be}

\item{n_boot}{number describing how many bootstrap datasets we want to use}

\item{quantiles}{A vector of two percentages describing how which quantiles of activity to keep}

\item{alpha}{number describing what quantile to check for the boostrapped test statistics}

\item{verbose}{TRUE/FALSE describing if you want to see progress of function}

\item{n_cores}{number describing how many cores to use}

\item{id_col}{the column that contains the subject ID column}

\item{activity_grid}{vector ofactivity counts derived from extract_activity_grid}

\item{lambda_gamma}{vector of parameters in equation, lambda followed by gamma}

\item{n_subj}{number describing how many subjects are in this particular group}

\item{group_id}{number describing the index of the group to differentiate it from others}

\item{n_points}{how much activity count data we want to produce for each person}

\item{scaling}{how much the activity data should be scaled}

\item{thetas}{numbers for parameters in creating Ornstein-Uhlenbeck process}

\item{mu_grid_length}{number describing how long the mu grid should be}

\item{lambda_grid_length}{number describing how long the lambda grid should be}

\item{mu_tolerance}{number describing how fine the different mus should be in the grid}

\item{lambda_tolerance}{number describing how fine the different mus should be in the grid}

\item{a}{activity index that describes where in the activity profiles to filter}

\item{group_params}{A list of parameters for each group in the simulated sample}

\item{Xt}{vector of activity counts for a subject}
}
\value{
a list contaning the results of the functional ANOVA test

a list contaning the results of the functional ANOVA test

the same dataset with an additional columns for the activity profiles and analysis

tibble containing extra helper columns "gamma" and "n"

a tibble with the results of all of the bootstrapping

a tibble with the results of all of the bootstrapping

a vector representing the activity profile for the data

a vector same length as lambda_gamma that optimizes the equation

a vector of equidistant activity values from the maximum to the 
minimum in the data

data containing the activity data

a tibble with all of the valid mu-lambda combinations from the data



A tibble of the activity for the sample

data with another column containing the scaled activity profiles
}
\description{
Takes all of the subject's activity counts, Xt, and transforms it
into the activity profile, Ta

Function uses bootstrap to calculate the uniform approximation
of the EL statistic U^2 described in Chang et. al. This function 
is used inside EL_test

Takes a dataset containing activity counts for multiple groups
and creates a standard grid/vector of activity counts that can 
be applied across all of the groups in the dataset. Activity counts
assumed to be nested. See output of prepare_sim_data

Simulates data for a group of subjects using an Ornstein-Uhlenbeck process
with user defined parameters for the process

Given parameters for each group, simulates activity data for each group.
}
\examples{
params_by_group = list(
  list(n_subj = 70, n_points = 1000, 
      scaling = 300, thetas = c(-0.8, 2.0, 2.31)),
 list(n_subj = 100, n_points = 1000, 
      scaling = 300, thetas = c(-0.402, 1.0, 1.65)),
 list(n_subj = 130, n_points = 1000, 
      scaling = 300, thetas = c(-0.201, 0.5, 1.18))
 )

data = prepare_sim_data(params_by_group)
el = EL_test(data, activity_col = Xt, group_col = group)

data = generate_data(n_subj = 70, group_id = 1, n_points = 1000, 
                     scaling = 300, thetas = c(-0.8, 2.0, 2.31))
params_by_group = list(
  list(n_subj = 70, n_points = 1000, 
      scaling = 300, thetas = c(-0.8, 2.0, 2.31)),
 list(n_subj = 100, n_points = 1000, 
      scaling = 300, thetas = c(-0.402, 1.0, 1.65)),
 list(n_subj = 130, n_points = 1000, 
      scaling = 300, thetas = c(-0.201, 0.5, 1.18))
 )

data = prepare_sim_data(params_by_group)

}
